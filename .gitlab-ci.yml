variables:
  # Docker configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  DOCKER_BUILDKIT: 1
  
  # Go configuration
  GO_VERSION: "1.25.6"
  
  # Image tags
  BACKEND_IMAGE: "${CI_REGISTRY_IMAGE}/backend"
  TRANSCODER_IMAGE: "${CI_REGISTRY_IMAGE}/transcoder"

  # Security scanning
  TRIVY_VERSION: "0.48.0"
  SNYK_ENABLED: "true"

  # SonarQube configuration
  SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
  # SONAR_HOST_URL: "https://sonarqube.example.com"
  GIT_DEPTH: "0"
  
  # ArgoCD configuration
  ARGOCD_SERVER: "argocd.example.com"
  ARGOCD_VERSION: "2.9.3"
  
  # GitOps repository
  GITOPS_REPO: "git@gitlab.com:subrotokumar/playstack.git"
  GITOPS_BRANCH: "main"

stages:
  - lint
  - test
  - sonarqube
  - build
  - container-scan
  - publish
  - update-manifests
  - sync

# Global cache for Go dependencies
.go_cache: &go_cache
  cache:
    key: go-modules-${CI_COMMIT_REF_SLUG}
    paths:
      - .cache/go-build
      - vendor/
      - .sonar/cache

# Global before_script for Go projects
.go_template: &go_template
  image: golang:${GO_VERSION}
  before_script:
    - go version
    - go env
    - mkdir -p .cache/go-build
    - export GOCACHE=$CI_PROJECT_DIR/.cache/go-build
  <<: *go_cache

# ==================== LINT STAGE ====================

lint:golang:
  <<: *go_template
  stage: lint
  script:
    - go mod download
    - go mod verify
    - go fmt ./...
    - test -z "$(gofmt -l .)"
    - go vet ./...
    - curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin ${GOLANGCI_LINT_VERSION}
    - golangci-lint run --timeout 5m --verbose
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'

lint:dockerfile:
  stage: lint
  image: hadolint/hadolint:latest-alpine
  script:
    - hadolint docker/backend.dockerfile
    - hadolint docker/transcoder.dockerfile
  allow_failure: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - docker/**/*
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

# lint:yaml:
#   stage: lint
#   image: cytopia/yamllint:latest
#   script:
#     - yamllint -c .yamllint.yml .
#   allow_failure: true
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
#     - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'


# ==================== TEST STAGE ====================

test:unit:
  <<: *go_template
  stage: test
  script:
    - go mod download
    - go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
    - go tool cover -html=coverage.out -o coverage.html
    - go tool cover -func=coverage.out | tee coverage.txt
  coverage: '/total:\s+\(statements\)\s+(\d+\.\d+)%/'
  artifacts:
    when: always
    reports:
      # GitLab native coverage report
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.out
      - coverage.html
      - coverage.txt
    expire_in: 30 days
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'

sonarqube:check:
  stage: sonarqube
  image: 
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
  dependencies:
    - test:unit
  allow_failure: true
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  only:
    variables:
      - $SONAR_TOKEN

sonarcloud:quality-gate:
  stage: sonarqube
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]

  script:
    # - apt install --no-cache curl jq
    - |
      TASK_URL=$(grep ceTaskUrl .scannerwork/report-task.txt | cut -d'=' -f2-)
      echo "CE Task URL: $TASK_URL"

      # Poll analysis status
      for i in $(seq 1 30); do
        RESPONSE=$(curl -s -u "${SONAR_TOKEN}:" "$TASK_URL")
        STATUS=$(echo "$RESPONSE" | jq -r '.task.status')
        echo "Analysis status: $STATUS"

        if [ "$STATUS" = "SUCCESS" ]; then
          ANALYSIS_ID=$(echo "$RESPONSE" | jq -r '.task.analysisId')

          QG_STATUS=$(curl -s \
            -u "${SONAR_TOKEN}:" \
            "https://sonarcloud.io/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}" \
            | jq -r '.projectStatus.status')

          echo "Quality Gate status: $QG_STATUS"

          if [ "$QG_STATUS" != "OK" ]; then
            echo "❌ Quality Gate FAILED"
            exit 1
          fi

          echo "✅ Quality Gate PASSED"
          exit 0
        fi

        sleep 5
      done

      echo "❌ Timeout waiting for Quality Gate"
      exit 1

  needs:
    - sonarqube:check

  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'
  timeout: 30s
  allow_failure: false

# ==================== BUILD STAGE ====================

.build_template: &build_template
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

build:backend:
  <<: *build_template
  script:
    - |
      # Set image tags
      export IMAGE_TAG=${CI_COMMIT_SHORT_SHA}
      export IMAGE_VERSIONED=${BACKEND_IMAGE}:${IMAGE_TAG}
      
      # Build image
      docker build \
        --file docker/backend.dockerfile \
        --tag ${IMAGE_VERSIONED} \
        --build-arg VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA} \
        --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --cache-from ${BACKEND_IMAGE}:latest \
        .
      
      # Push image with commit SHA
      docker push ${IMAGE_VERSIONED}
      
      # Tag and push with semantic version if tag exists
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag ${IMAGE_VERSIONED} ${BACKEND_IMAGE}:${CI_COMMIT_TAG}
        docker push ${BACKEND_IMAGE}:${CI_COMMIT_TAG}
        
        docker tag ${IMAGE_VERSIONED} ${BACKEND_IMAGE}:latest
        docker push ${BACKEND_IMAGE}:latest
      fi
      
      # For main branch, tag as environment-specific
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_VERSIONED} ${BACKEND_IMAGE}:staging
        docker push ${BACKEND_IMAGE}:staging
      fi
      
      # For develop branch
      if [ "$CI_COMMIT_BRANCH" == "develop" ]; then
        docker tag ${IMAGE_VERSIONED} ${BACKEND_IMAGE}:dev
        docker push ${BACKEND_IMAGE}:dev
      fi
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_COMMIT_TAG'

build:transcoder:
  <<: *build_template
  script:
    - |
      # Set image tags
      export IMAGE_TAG=${CI_COMMIT_SHORT_SHA}
      export IMAGE_VERSIONED=${TRANSCODER_IMAGE}:${IMAGE_TAG}
      
      # Build image
      docker build \
        --file docker/transcoder.dockerfile \
        --tag ${IMAGE_VERSIONED} \
        --build-arg VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA} \
        --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
        --build-arg VCS_REF=${CI_COMMIT_SHA} \
        --cache-from ${TRANSCODER_IMAGE}:latest \
        .
      
      # Push image with commit SHA
      docker push ${IMAGE_VERSIONED}
      
      # Tag and push with semantic version if tag exists
      if [ -n "$CI_COMMIT_TAG" ]; then
        docker tag ${IMAGE_VERSIONED} ${TRANSCODER_IMAGE}:${CI_COMMIT_TAG}
        docker push ${TRANSCODER_IMAGE}:${CI_COMMIT_TAG}
        
        docker tag ${IMAGE_VERSIONED} ${TRANSCODER_IMAGE}:latest
        docker push ${TRANSCODER_IMAGE}:latest
      fi
      
      # For main branch, tag as environment-specific
      if [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]; then
        docker tag ${IMAGE_VERSIONED} ${TRANSCODER_IMAGE}:staging
        docker push ${TRANSCODER_IMAGE}:staging
      fi
      
      # For develop branch
      if [ "$CI_COMMIT_BRANCH" == "develop" ]; then
        docker tag ${IMAGE_VERSIONED} ${TRANSCODER_IMAGE}:dev
        docker push ${TRANSCODER_IMAGE}:dev
      fi
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_COMMIT_TAG'

# ==================== CONTAINER SCAN STAGE ====================

# Use GitLab's built-in Container Scanning (GitLab Ultimate/Premium)
# For free tier, use Trivy
container_scanning:backend:
  stage: container-scan
  image: docker:24
  services:
    - docker:24-dind
  variables:
    IMAGE: ${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - apk add --no-cache curl
    - export TRIVY_VERSION=0.48.0
    - |
      curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - trivy image --exit-code 0 --no-progress --format json -o gl-container-scanning-backend.json ${IMAGE}
    - trivy image --exit-code 1 --severity CRITICAL --no-progress ${IMAGE}
  artifacts:
    reports:
      # GitLab native container scanning report format
      container_scanning: gl-container-scanning-backend.json
    paths:
      - gl-container-scanning-backend.json
    expire_in: 30 days
  dependencies:
    - build:backend
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_COMMIT_TAG'

container_scanning:transcoder:
  stage: container-scan
  image: docker:24
  services:
    - docker:24-dind
  variables:
    IMAGE: ${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_VERIFY: 1
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - apk add --no-cache curl
    - export TRIVY_VERSION=0.48.0
    - |
      curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v${TRIVY_VERSION}
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - trivy image --exit-code 0 --no-progress --format json -o gl-container-scanning-transcoder.json ${IMAGE}
    - trivy image --exit-code 1 --severity CRITICAL --no-progress ${IMAGE}
  artifacts:
    reports:
      container_scanning: gl-container-scanning-transcoder.json
    paths:
      - gl-container-scanning-transcoder.json
    expire_in: 30 days
  dependencies:
    - build:transcoder
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_COMMIT_TAG'

# ==================== PUBLISH STAGE ====================

publish:images:
  stage: publish
  image: alpine:latest
  script:
    - echo "BACKEND_IMAGE_TAG=${CI_COMMIT_SHORT_SHA}" >> publish.env
    - echo "TRANSCODER_IMAGE_TAG=${CI_COMMIT_SHORT_SHA}" >> publish.env
    - echo "Images published successfully"
    # - echo "Backend: ${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}"
    # - echo "Transcoder: ${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  artifacts:
    reports:
      dotenv: publish.env
    expire_in: 1 day
  dependencies:
    - container_scanning:backend
    - container_scanning:transcoder
  rules:
  - if: '$CI_COMMIT_TAG'
    when: on_success
  - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    when: on_success
  - if: '$CI_COMMIT_BRANCH == "develop"'
    when: on_success


# ==================== UPDATE MANIFESTS STAGE ====================

.update_manifests_template: &update_manifests_template
  stage: update-manifests
  image: alpine:latest
  before_script:
    - apk add --no-cache git openssh-client yq jq
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$GITOPS_SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
    - git config --global user.email "${GITLAB_USER_EMAIL}"
    - git config --global user.name "${GITLAB_USER_NAME}"

update:manifests:dev:
  <<: *update_manifests_template
  variables:
    ENVIRONMENT: dev
  script:
    - |
      # Clone GitOps repository
      git clone ${GITOPS_REPO} gitops
      cd gitops
      git checkout ${GITOPS_BRANCH}
      
      # Update backend image tag
      yq eval ".spec.template.spec.containers[0].image = \"${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/dev/backend/deployment.yaml
      
      # Update transcoder image tag
      yq eval ".spec.template.spec.containers[0].image = \"${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/dev/transcoder/deployment.yaml
      
      # Update version in kustomization
      yq eval ".images[0].newTag = \"${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/dev/backend/kustomization.yaml
      yq eval ".images[0].newTag = \"${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/dev/transcoder/kustomization.yaml
      
      # Commit and push changes
      git add -A
      if git diff --staged --quiet; then
        echo "No changes to commit"
      else
        git commit -m "Update dev images to ${CI_COMMIT_SHORT_SHA}
        
        Backend: ${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}
        Transcoder: ${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}
        
        Source: ${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA}
        Pipeline: ${CI_PIPELINE_URL}"
        
        git push origin ${GITOPS_BRANCH}
        echo "Manifests updated successfully"
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'

update:manifests:staging:
  <<: *update_manifests_template
  variables:
    ENVIRONMENT: staging
  script:
    - |
      # Clone GitOps repository
      git clone ${GITOPS_REPO} gitops
      cd gitops
      git checkout ${GITOPS_BRANCH}
      
      # Update backend image tag
      yq eval ".spec.template.spec.containers[0].image = \"${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/staging/backend/deployment.yaml
      
      # Update transcoder image tag
      yq eval ".spec.template.spec.containers[0].image = \"${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/staging/transcoder/deployment.yaml
      
      # Update version in kustomization
      yq eval ".images[0].newTag = \"${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/staging/backend/kustomization.yaml
      yq eval ".images[0].newTag = \"${CI_COMMIT_SHORT_SHA}\"" \
        -i environments/staging/transcoder/kustomization.yaml
      
      # Commit and push changes
      git add -A
      if git diff --staged --quiet; then
        echo "No changes to commit"
      else
        git commit -m "Update staging images to ${CI_COMMIT_SHORT_SHA}
        
        Backend: ${BACKEND_IMAGE}:${CI_COMMIT_SHORT_SHA}
        Transcoder: ${TRANSCODER_IMAGE}:${CI_COMMIT_SHORT_SHA}
        
        Source: ${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA}
        Pipeline: ${CI_PIPELINE_URL}"
        
        git push origin ${GITOPS_BRANCH}
        echo "Manifests updated successfully"
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

update:manifests:production:
  <<: *update_manifests_template
  variables:
    ENVIRONMENT: production
  script:
    - |
      # Clone GitOps repository
      git clone ${GITOPS_REPO} gitops
      cd gitops
      git checkout ${GITOPS_BRANCH}
      
      # Update backend image tag with version tag
      yq eval ".spec.template.spec.containers[0].image = \"${BACKEND_IMAGE}:${CI_COMMIT_TAG}\"" \
        -i environments/production/backend/deployment.yaml
      
      # Update transcoder image tag with version tag
      yq eval ".spec.template.spec.containers[0].image = \"${TRANSCODER_IMAGE}:${CI_COMMIT_TAG}\"" \
        -i environments/production/transcoder/deployment.yaml
      
      # Update version in kustomization
      yq eval ".images[0].newTag = \"${CI_COMMIT_TAG}\"" \
        -i environments/production/backend/kustomization.yaml
      yq eval ".images[0].newTag = \"${CI_COMMIT_TAG}\"" \
        -i environments/production/transcoder/kustomization.yaml
      
      # Commit and push changes
      git add -A
      if git diff --staged --quiet; then
        echo "No changes to commit"
      else
        git commit -m "Release ${CI_COMMIT_TAG} to production
        
        Backend: ${BACKEND_IMAGE}:${CI_COMMIT_TAG}
        Transcoder: ${TRANSCODER_IMAGE}:${CI_COMMIT_TAG}
        
        Source: ${CI_PROJECT_URL}/-/commit/${CI_COMMIT_SHA}
        Pipeline: ${CI_PIPELINE_URL}"
        
        git push origin ${GITOPS_BRANCH}
        echo "Production manifests updated successfully"
      fi
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
      when: manual
  only:
    - tags

# ==================== ARGOCD SYNC STAGE ====================

.argocd_sync_template: &argocd_sync_template
  stage: sync
  image: argoproj/argocd:v${ARGOCD_VERSION}
  before_script:
    - argocd version --client
    - argocd login ${ARGOCD_SERVER} --username ${ARGOCD_USERNAME} --password ${ARGOCD_PASSWORD} --grpc-web

sync:argocd:dev:
  <<: *argocd_sync_template
  script:
    - |
      # Sync backend application
      argocd app sync backend-dev --prune --force
      argocd app wait backend-dev --timeout 300 --health
      
      # Sync transcoder application
      argocd app sync transcoder-dev --prune --force
      argocd app wait transcoder-dev --timeout 300 --health
      
      echo "Development deployment completed successfully"
  dependencies:
    - update:manifests:dev
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: on_success

sync:argocd:staging:
  <<: *argocd_sync_template
  script:
    - |
      # Sync backend application
      argocd app sync backend-staging --prune --force
      argocd app wait backend-staging --timeout 600 --health
      
      # Sync transcoder application
      argocd app sync transcoder-staging --prune --force
      argocd app wait transcoder-staging --timeout 600 --health
      
      echo "Staging deployment completed successfully"
  dependencies:
    - update:manifests:staging
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: on_success

sync:argocd:production:
  <<: *argocd_sync_template
  script:
    - |
      # Sync backend application with health check
      argocd app sync backend-production --prune --force
      argocd app wait backend-production --timeout 900 --health
      
      # Verify deployment health
      BACKEND_HEALTH=$(argocd app get backend-production -o json | jq -r '.status.health.status')
      if [ "$BACKEND_HEALTH" != "Healthy" ]; then
        echo "Backend deployment is not healthy: $BACKEND_HEALTH"
        exit 1
      fi
      
      # Sync transcoder application
      argocd app sync transcoder-production --prune --force
      argocd app wait transcoder-production --timeout 900 --health
      
      # Verify deployment health
      TRANSCODER_HEALTH=$(argocd app get transcoder-production -o json | jq -r '.status.health.status')
      if [ "$TRANSCODER_HEALTH" != "Healthy" ]; then
        echo "Transcoder deployment is not healthy: $TRANSCODER_HEALTH"
        exit 1
      fi
      
      echo "Production deployment completed successfully"
      echo "Release ${CI_COMMIT_TAG} is now live in production"
  dependencies:
    - update:manifests:production
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
      when: manual
  only:
    - tags

# ==================== ROLLBACK ====================

rollback:production:
  stage: sync
  image: argoproj/argocd:v${ARGOCD_VERSION}
  before_script:
    - argocd version --client
    - argocd login ${ARGOCD_SERVER} --username ${ARGOCD_USERNAME} --password ${ARGOCD_PASSWORD} --grpc-web
  script:
    - |
      echo "Rolling back production applications..."
      
      # Rollback backend
      argocd app rollback backend-production --prune
      argocd app wait backend-production --timeout 600 --health
      
      # Rollback transcoder
      argocd app rollback transcoder-production --prune
      argocd app wait transcoder-production --timeout 600 --health
      
      echo "Rollback completed successfully"
  when: manual
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
  only:
    - tags

# ==================== UTILITY JOBS ====================

argocd:app:status:
  stage: sync
  image: argoproj/argocd:v${ARGOCD_VERSION}
  before_script:
    - argocd version --client
    - argocd login ${ARGOCD_SERVER} --username ${ARGOCD_USERNAME} --password ${ARGOCD_PASSWORD} --grpc-web
  script:
    - |
      echo "=== Development Environment ==="
      argocd app get backend-dev
      argocd app get transcoder-dev
      
      echo ""
      echo "=== Staging Environment ==="
      argocd app get backend-staging
      argocd app get transcoder-staging
      
      echo ""
      echo "=== Production Environment ==="
      argocd app get backend-production
      argocd app get transcoder-production
  when: manual
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'